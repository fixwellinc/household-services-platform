generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                String                       @id @default(cuid())
  email             String                       @unique
  password          String
  name              String?
  role              String                       @default("CUSTOMER")
  avatar            String?
  phone             String?
  address           String?
  createdAt         DateTime                     @default(now())
  updatedAt         DateTime                     @updatedAt
  subscriptionId    String?
  serviceIds        String[]
  bookingIds        String[]
  messageIds        String[]
  quoteIds          String[]
  isActive          Boolean                      @default(true)
  notifications     Json?                        @default("{\"sms\": false, \"email\": true}")
  postalCode        String?
  
  // Suspension tracking fields
  suspendedAt       DateTime?
  suspendedBy       String?
  suspensionReason  String?
  activatedAt       DateTime?
  activatedBy       String?
  activationReason  String?
  assignedEmployee  CustomerEmployeeAssignment?  @relation("CustomerAssignment")
  assignedCustomers CustomerEmployeeAssignment[] @relation("EmployeeAssignments")
  subscriptionUsage SubscriptionUsage?
  
  // Add relation to Subscription
  subscription      Subscription?
  
  // New relations for complete workflow
  serviceRequests   ServiceRequest[] @relation("CustomerServiceRequests")
  technicianServiceRequests ServiceRequest[] @relation("TechnicianServiceRequests")
  technicianQuotes Quote[] @relation("TechnicianQuotes")
  customerJobs     Job[]   @relation("CustomerJobs")
  technicianJobs   Job[]   @relation("TechnicianJobs")
  customerInvoices Invoice[] @relation("CustomerInvoices")
  technicianInvoices Invoice[] @relation("TechnicianInvoices")
  
  // New relations for flexible payment options
  familyMemberships FamilyMember[] @relation("FamilyMemberUser")
  rewardCredits     RewardCredit[] @relation("UserRewardCredits")
  installmentPlans  InstallmentPlan[] @relation("UserInstallmentPlans")
  
  // Audit log relation
  auditLogs         AuditLog[] @relation("AdminAuditLogs")
  
  // Granular permission system relations
  userRoles         UserRole[] @relation("UserRoles")
  assignedRoles     UserRole[] @relation("AssignedByUser")
  impersonationSessions ImpersonationSession[] @relation("AdminImpersonationSessions")
  targetedImpersonations ImpersonationSession[] @relation("TargetUserImpersonationSessions")
  
  // Suspension tracking relations
  suspendedByUser   User?      @relation("UserSuspensions", fields: [suspendedBy], references: [id])
  suspendedUsers    User[]     @relation("UserSuspensions")
  activatedByUser   User?      @relation("UserActivations", fields: [activatedBy], references: [id])
  activatedUsers    User[]     @relation("UserActivations")
  
  // Billing adjustment relations
  createdBillingAdjustments   BillingAdjustment[] @relation("CreatedBillingAdjustments")
  approvedBillingAdjustments  BillingAdjustment[] @relation("ApprovedBillingAdjustments")
  rejectedBillingAdjustments  BillingAdjustment[] @relation("RejectedBillingAdjustments")
  processedBillingAdjustments BillingAdjustment[] @relation("ProcessedBillingAdjustments")
  
  // Appointment booking relations
  customerAppointments        Appointment[]       @relation("CustomerAppointments")
  notificationPreferences     NotificationPreference? @relation("UserNotificationPreferences")
  notificationDeliveries      NotificationDelivery[] @relation("UserNotificationDeliveries")
}

model CustomerEmployeeAssignment {
  id         String   @id @default(cuid())
  customerId String   @unique
  employeeId String
  assignedAt DateTime @default(now())
  updatedAt  DateTime @updatedAt
  customer   User     @relation("CustomerAssignment", fields: [customerId], references: [id])
  employee   User     @relation("EmployeeAssignments", fields: [employeeId], references: [id])
}

model Subscription {
  id                        String    @id @default(cuid())
  userId                    String    @unique
  tier                      String
  status                    String    @default("ACTIVE")
  stripeCustomerId          String?
  stripeSubscriptionId      String?
  currentPeriodStart        DateTime?
  currentPeriodEnd          DateTime?
  createdAt                 DateTime  @default(now())
  updatedAt                 DateTime  @updatedAt
  canCancel                 Boolean   @default(true)
  cancellationBlockedAt     DateTime?
  cancellationBlockedReason String?
  
  // New fields for flexible payment options
  paymentFrequency          String    @default("MONTHLY") // WEEKLY, BIWEEKLY, MONTHLY, QUARTERLY, YEARLY
  nextPaymentAmount         Float?
  isPaused                  Boolean   @default(false)
  pauseStartDate            DateTime?
  pauseEndDate              DateTime?
  availableCredits          Float     @default(0)
  loyaltyPoints             Int       @default(0)
  churnRiskScore            Float     @default(0)
  lifetimeValue             Float     @default(0)
  
  // Add relation back to User
  user                     User      @relation(fields: [userId], references: [id])
  
  // New relations for flexible payment options
  paymentFrequencies       PaymentFrequency[]
  subscriptionPauses       SubscriptionPause[]
  familyMembers            FamilyMember[]
  additionalProperties     AdditionalProperty[]
  
  // Billing adjustment relations
  billingAdjustments       BillingAdjustment[]    @relation("SubscriptionBillingAdjustments")
  creditTransactions       CreditTransaction[]    @relation("SubscriptionCreditTransactions")
  subscriptionDiscounts    SubscriptionDiscount[] @relation("SubscriptionDiscounts")
  pendingCharges           PendingCharge[]        @relation("SubscriptionPendingCharges")
}

model SubscriptionUsage {
  id                     String    @id @default(cuid())
  userId                 String    @unique
  subscriptionId         String
  tier                   String
  priorityBookingUsed    Boolean   @default(false)
  priorityBookingUsedAt  DateTime?
  priorityBookingCount   Int       @default(0)
  discountUsed           Boolean   @default(false)
  discountUsedAt         DateTime?
  discountAmount         Float     @default(0)
  freeServiceUsed        Boolean   @default(false)
  freeServiceUsedAt      DateTime?
  freeServiceType        String?
  emergencyServiceUsed   Boolean   @default(false)
  emergencyServiceUsedAt DateTime?
  maxPriorityBookings    Int       @default(0)
  maxDiscountAmount      Float     @default(0)
  maxFreeServices        Int       @default(0)
  maxEmergencyServices   Int       @default(0)
  createdAt              DateTime  @default(now())
  updatedAt              DateTime  @updatedAt
  user                   User      @relation(fields: [userId], references: [id])
}

model Service {
  id          String   @id @default(cuid())
  name        String   @unique
  description String
  category    String
  complexity  String
  basePrice   Float
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  bookingIds  String[]
  quoteIds    String[]
  serviceRequestIds String[]
  serviceRequests ServiceRequest[] @relation("ServiceToServiceRequests")
}

model Booking {
  id                    String   @id @default(cuid())
  customerId            String
  serviceId             String
  scheduledDate         DateTime
  status                String   @default("PENDING")
  totalAmount           Float
  discountAmount        Float   @default(0)
  finalAmount           Float
  notes                 String?
  stripePaymentIntentId String?
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  messageIds            String[]
  perkType              String?
  usedSubscriptionPerk  Boolean @default(false)
}

model Message {
  id         String   @id @default(cuid())
  bookingId  String
  senderId   String
  receiverId String
  content    String
  isRead     Boolean  @default(false)
  createdAt  DateTime @default(now())
}

model Quote {
  id               String    @id @default(cuid())
  userId           String?
  email            String
  serviceId        String?
  message          String
  status           String    @default("PENDING")
  adminReply       String?
  adminReplyPrice  Float?
  adminReplySentAt DateTime?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  serviceRequestId String?
  technicianId     String?
  estimatedHours   Float?
  materialsCost    Float?
  laborCost        Float?
  totalCost        Float?
  technicianNotes  String?
  customerAccepted Boolean   @default(false)
  acceptedAt       DateTime?
  serviceRequest   ServiceRequest? @relation("QuoteToServiceRequest", fields: [serviceRequestId], references: [id])
  technician       User?     @relation("TechnicianQuotes", fields: [technicianId], references: [id])
  jobs             Job[]      @relation("QuoteToJob")
}

model Setting {
  id        String   @id @default(cuid())
  key       String   @unique
  value     String
  updatedAt DateTime @updatedAt
}

model EmailTemplate {
  id         String   @id @default(cuid())
  name       String   @unique
  subject    String
  body       String?
  html       String?
  isHtmlMode Boolean  @default(false)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  createdBy  String?
}

model ChatSession {
  id                 String        @id @default(cuid())
  customerName       String
  customerEmail      String?
  status             String        @default("ACTIVE")
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt
  lastAdminReadAt    DateTime?
  lastCustomerReadAt DateTime?
  messages           ChatMessage[]
}

model ChatMessage {
  id            String      @id @default(cuid())
  chatSessionId String
  sender        String
  senderType    String
  message       String
  sentAt        DateTime    @default(now())
  viaSMS        Boolean     @default(false)
  readBy        String[]
  fileName      String?
  fileType      String?
  fileUrl       String?
  chatSession   ChatSession @relation(fields: [chatSessionId], references: [id])
}

// New models for complete workflow
model ServiceRequest {
  id                String   @id @default(cuid())
  customerId        String
  serviceId         String?
  category          String
  description       String
  urgency           String   @default("NORMAL") // LOW, NORMAL, HIGH, EMERGENCY
  status            String   @default("PENDING") // PENDING, ASSIGNED, IN_PROGRESS, COMPLETED, CANCELLED
  photos            String[] // URLs to uploaded photos
  videos            String[] // URLs to uploaded videos
  address           String?
  preferredDate    DateTime?
  assignedTechnicianId String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  customer          User     @relation("CustomerServiceRequests", fields: [customerId], references: [id])
  service           Service? @relation("ServiceToServiceRequests", fields: [serviceId], references: [id])
  assignedTechnician User?   @relation("TechnicianServiceRequests", fields: [assignedTechnicianId], references: [id])
  quotes            Quote[]  @relation("QuoteToServiceRequest")
  jobs              Job[]     @relation("ServiceRequestToJob")
}

model Job {
  id                String   @id @default(cuid())
  serviceRequestId  String
  quoteId           String?
  customerId        String
  technicianId      String
  status            String   @default("SCHEDULED") // SCHEDULED, IN_PROGRESS, COMPLETED, CANCELLED
  scheduledDate     DateTime
  startTime         DateTime?
  endTime           DateTime?
  actualHours       Float?
  materialsUsed     String?
  notes             String?
  customerRating    Int?     // 1-5 stars
  customerFeedback  String?
  completedAt       DateTime?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  serviceRequest    ServiceRequest @relation("ServiceRequestToJob", fields: [serviceRequestId], references: [id])
  quote             Quote?   @relation("QuoteToJob", fields: [quoteId], references: [id])
  customer          User     @relation("CustomerJobs", fields: [customerId], references: [id])
  technician        User     @relation("TechnicianJobs", fields: [technicianId], references: [id])
  invoices          Invoice[] @relation("JobToInvoice")
}

model Invoice {
  id                String   @id @default(cuid())
  jobId             String
  customerId        String
  technicianId      String
  invoiceNumber     String   @unique
  subtotal          Float
  taxAmount         Float
  discountAmount    Float   @default(0)
  totalAmount       Float
  status            String   @default("PENDING") // PENDING, PAID, OVERDUE, CANCELLED
  dueDate           DateTime
  paidAt            DateTime?
  stripePaymentIntentId String?
  pdfUrl            String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  job               Job      @relation("JobToInvoice", fields: [jobId], references: [id])
  customer          User     @relation("CustomerInvoices", fields: [customerId], references: [id])
  technician        User     @relation("TechnicianInvoices", fields: [technicianId], references: [id])
}

enum SubscriptionTier {
  STARTER
  HOMECARE
  PRIORITY
}

// New models for flexible payment options
model PaymentFrequency {
  id             String @id @default(cuid())
  subscriptionId String
  frequency      String // WEEKLY, BIWEEKLY, MONTHLY, QUARTERLY, YEARLY
  amount         Float
  nextPaymentDate DateTime
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  subscription   Subscription @relation(fields: [subscriptionId], references: [id])
}

model SubscriptionPause {
  id             String @id @default(cuid())
  subscriptionId String
  startDate      DateTime
  endDate        DateTime
  reason         String?
  status         String @default("ACTIVE") // ACTIVE, COMPLETED, CANCELLED
  createdAt      DateTime @default(now())
  subscription   Subscription @relation(fields: [subscriptionId], references: [id])
}

model FamilyMember {
  id             String @id @default(cuid())
  subscriptionId String
  userId         String
  relationship   String
  addedAt        DateTime @default(now())
  subscription   Subscription @relation(fields: [subscriptionId], references: [id])
  user           User @relation("FamilyMemberUser", fields: [userId], references: [id])
}

model AdditionalProperty {
  id             String @id @default(cuid())
  subscriptionId String
  address        String
  nickname       String?
  monthlyFee     Float
  addedAt        DateTime @default(now())
  subscription   Subscription @relation(fields: [subscriptionId], references: [id])
}

model RewardCredit {
  id             String @id @default(cuid())
  userId         String
  amount         Float
  type           String // REFERRAL, LOYALTY, BONUS
  description    String
  earnedAt       DateTime @default(now())
  usedAt         DateTime?
  expiresAt      DateTime?
  user           User @relation("UserRewardCredits", fields: [userId], references: [id])
}

model InstallmentPlan {
  id             String @id @default(cuid())
  userId         String
  serviceQuoteId String?
  provider       String // KLARNA, AFFIRM, SEZZLE
  totalAmount    Float
  monthlyAmount  Float
  duration       Int
  remainingBalance Float
  status         String @default("ACTIVE")
  createdAt      DateTime @default(now())
  user           User @relation("UserInstallmentPlans", fields: [userId], references: [id])
}

model AuditLog {
  id         String   @id @default(cuid())
  adminId    String
  action     String
  entityType String
  entityId   String
  changes    String   // JSON string of changes
  metadata   String   // JSON string of metadata
  severity   String   @default("medium") // low, medium, high, critical
  createdAt  DateTime @default(now())
  
  // Relation to admin user
  admin      User     @relation("AdminAuditLogs", fields: [adminId], references: [id])
  
  @@index([adminId])
  @@index([action])
  @@index([entityType])
  @@index([severity])
  @@index([createdAt])
}

// Granular Permission System Models
model Permission {
  id          String   @id @default(cuid())
  name        String   @unique
  resource    String
  action      String
  description String?
  category    String   @default("general")
  isSystem    Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  rolePermissions RolePermission[]
  
  @@unique([resource, action])
  @@index([resource])
  @@index([category])
}

model Role {
  id          String   @id @default(cuid())
  name        String   @unique
  description String?
  isSystem    Boolean  @default(false)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  rolePermissions RolePermission[]
  userRoles       UserRole[]
}

model RolePermission {
  id           String   @id @default(cuid())
  roleId       String
  permissionId String
  conditions   Json?    // Additional conditions for the permission
  createdAt    DateTime @default(now())
  
  // Relations
  role         Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  
  @@unique([roleId, permissionId])
  @@index([roleId])
  @@index([permissionId])
}

model UserRole {
  id         String    @id @default(cuid())
  userId     String
  roleId     String
  assignedBy String
  assignedAt DateTime  @default(now())
  expiresAt  DateTime?
  isActive   Boolean   @default(true)
  
  // Relations
  user       User @relation("UserRoles", fields: [userId], references: [id], onDelete: Cascade)
  role       Role @relation(fields: [roleId], references: [id], onDelete: Cascade)
  assignedByUser User @relation("AssignedByUser", fields: [assignedBy], references: [id])
  
  @@unique([userId, roleId])
  @@index([userId])
  @@index([roleId])
  @@index([assignedBy])
}

model ImpersonationSession {
  id           String    @id @default(cuid())
  adminId      String
  targetUserId String
  reason       String
  startedAt    DateTime  @default(now())
  endedAt      DateTime?
  isActive     Boolean   @default(true)
  ipAddress    String?
  userAgent    String?
  
  // Relations
  admin        User @relation("AdminImpersonationSessions", fields: [adminId], references: [id], onDelete: Cascade)
  targetUser   User @relation("TargetUserImpersonationSessions", fields: [targetUserId], references: [id], onDelete: Cascade)
  
  @@index([adminId])
  @@index([targetUserId])
  @@index([isActive])
}

// Billing Adjustment Models
model BillingAdjustment {
  id               String    @id @default(cuid())
  subscriptionId   String
  type             String    // credit, debit, refund, discount
  amount           Float
  reason           String
  description      String
  effectiveDate    DateTime
  status           String    @default("PENDING_APPROVAL") // PENDING_APPROVAL, APPROVED, REJECTED, PROCESSED, FAILED
  requiresApproval Boolean   @default(true)
  metadata         String?   // JSON string for additional data
  
  // Audit fields
  createdBy        String
  createdAt        DateTime  @default(now())
  approvedBy       String?
  approvedAt       DateTime?
  approvalNotes    String?
  rejectedBy       String?
  rejectedAt       DateTime?
  rejectionReason  String?
  processedBy      String?
  processedAt      DateTime?
  errorMessage     String?
  
  // Relations
  subscription     Subscription @relation("SubscriptionBillingAdjustments", fields: [subscriptionId], references: [id], onDelete: Cascade)
  createdByUser    User         @relation("CreatedBillingAdjustments", fields: [createdBy], references: [id])
  approvedByUser   User?        @relation("ApprovedBillingAdjustments", fields: [approvedBy], references: [id])
  rejectedByUser   User?        @relation("RejectedBillingAdjustments", fields: [rejectedBy], references: [id])
  processedByUser  User?        @relation("ProcessedBillingAdjustments", fields: [processedBy], references: [id])
  
  // Related records
  creditTransactions    CreditTransaction[]
  subscriptionDiscounts SubscriptionDiscount[]
  pendingCharges        PendingCharge[]
  
  @@index([subscriptionId])
  @@index([status])
  @@index([type])
  @@index([createdAt])
  @@index([requiresApproval])
}

model CreditTransaction {
  id                   String    @id @default(cuid())
  subscriptionId       String
  type                 String    // CREDIT, DEBIT, REFUND
  amount               Float
  description          String
  billingAdjustmentId  String?
  createdAt            DateTime  @default(now())
  
  // Relations
  subscription         Subscription      @relation("SubscriptionCreditTransactions", fields: [subscriptionId], references: [id], onDelete: Cascade)
  billingAdjustment    BillingAdjustment? @relation(fields: [billingAdjustmentId], references: [id])
  
  @@index([subscriptionId])
  @@index([type])
  @@index([createdAt])
}

model SubscriptionDiscount {
  id                   String    @id @default(cuid())
  subscriptionId       String
  amount               Float
  type                 String    @default("FIXED_AMOUNT") // FIXED_AMOUNT, PERCENTAGE
  description          String
  code                 String?
  expiresAt            DateTime?
  billingAdjustmentId  String?
  isActive             Boolean   @default(true)
  createdAt            DateTime  @default(now())
  
  // Relations
  subscription         Subscription      @relation("SubscriptionDiscounts", fields: [subscriptionId], references: [id], onDelete: Cascade)
  billingAdjustment    BillingAdjustment? @relation(fields: [billingAdjustmentId], references: [id])
  
  @@index([subscriptionId])
  @@index([isActive])
  @@index([expiresAt])
}

model PendingCharge {
  id                   String    @id @default(cuid())
  subscriptionId       String
  amount               Float
  description          String
  billingAdjustmentId  String?
  status               String    @default("PENDING") // PENDING, PROCESSED, FAILED
  stripePaymentIntentId String?
  processedAt          DateTime?
  createdAt            DateTime  @default(now())
  
  // Relations
  subscription         Subscription      @relation("SubscriptionPendingCharges", fields: [subscriptionId], references: [id], onDelete: Cascade)
  billingAdjustment    BillingAdjustment? @relation(fields: [billingAdjustmentId], references: [id])
  
  @@index([subscriptionId])
  @@index([status])
  @@index([createdAt])
}

// Appointment Booking Calendar Models
model Appointment {
  id                String      @id @default(cuid())
  customerId        String
  serviceTypeId     String
  scheduledDate     DateTime
  duration          Int         // minutes
  status            String      @default("PENDING") // PENDING, CONFIRMED, CANCELLED, COMPLETED
  customerName      String
  customerEmail     String
  customerPhone     String?
  propertyAddress   String
  notes             String?
  calendarEventId   String?     // External calendar event ID
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  
  // Relations
  customer          User?       @relation("CustomerAppointments", fields: [customerId], references: [id])
  serviceType       ServiceType @relation("ServiceTypeAppointments", fields: [serviceTypeId], references: [id])
  notifications     NotificationDelivery[] @relation("AppointmentNotifications")
  
  @@index([scheduledDate])
  @@index([status])
  @@index([customerId])
  @@index([serviceTypeId])
  @@index([scheduledDate, status])
  @@index([scheduledDate, serviceTypeId])
  @@index([customerEmail])
  @@index([createdAt, status])
}

model ServiceType {
  id                    String    @id @default(cuid())
  name                  String    @unique
  displayName           String
  description           String?
  duration              Int       // Default duration in minutes
  bufferMinutes         Int       @default(30) // Buffer time after appointment
  isActive              Boolean   @default(true)
  color                 String?   // Hex color for calendar display
  maxBookingsPerDay     Int       @default(8)
  requiresApproval      Boolean   @default(false)
  isExclusive           Boolean   @default(false) // If true, no other appointments on same day
  exclusiveDays         Int[]     @default([]) // Days of week (0-6) where this service is exclusive
  allowedDays           Int[]     @default([0,1,2,3,4,5,6]) // Days of week when service is available
  minAdvanceHours       Int       @default(24) // Minimum hours in advance for booking
  maxAdvanceDays        Int       @default(30) // Maximum days in advance for booking
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  
  // Relations
  appointments          Appointment[] @relation("ServiceTypeAppointments")
  availabilityRules     AvailabilityRule[] @relation("ServiceTypeAvailabilityRules")
  
  @@index([name])
  @@index([isActive])
}

model AvailabilityRule {
  id                String      @id @default(cuid())
  dayOfWeek         Int         // 0-6 (Sunday-Saturday)
  isAvailable       Boolean     @default(true)
  startTime         String      // HH:MM format
  endTime           String      // HH:MM format
  serviceTypeId     String?     // Optional service-specific availability
  bufferMinutes     Int         @default(30)
  maxBookingsPerDay Int         @default(8)
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  
  // Relations
  serviceType       ServiceType? @relation("ServiceTypeAvailabilityRules", fields: [serviceTypeId], references: [id])
  
  @@unique([dayOfWeek, serviceTypeId])
  @@index([dayOfWeek])
  @@index([isAvailable])
  @@index([serviceTypeId])
}

model CalendarSync {
  id                String    @id @default(cuid())
  provider          String    // "google", "outlook"
  accessToken       String
  refreshToken      String
  calendarId        String
  isActive          Boolean   @default(true)
  lastSyncAt        DateTime?
  syncErrors        String?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
}

// Notification Preference Models
model NotificationPreference {
  id                    String    @id @default(cuid())
  userId                String    @unique
  emailEnabled          Boolean   @default(true)
  smsEnabled            Boolean   @default(false)
  pushEnabled           Boolean   @default(true)
  
  // Appointment-specific preferences
  appointmentConfirmation Boolean @default(true)
  appointmentReminder     Boolean @default(true)
  appointmentCancellation Boolean @default(true)
  appointmentReschedule   Boolean @default(true)
  appointmentStatusChange Boolean @default(true)
  
  // Admin notification preferences
  newBookingAlert         Boolean @default(true)
  urgentAppointmentAlert  Boolean @default(true)
  dailyAppointmentSummary Boolean @default(true)
  
  // Delivery preferences
  reminderHoursBefore     Int     @default(24) // Hours before appointment to send reminder
  maxRetryAttempts        Int     @default(3)
  retryIntervalMinutes    Int     @default(30)
  
  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt
  
  // Relations
  user                    User     @relation("UserNotificationPreferences", fields: [userId], references: [id])
  
  @@index([userId])
}

model NotificationDelivery {
  id                String    @id @default(cuid())
  userId            String
  appointmentId     String?
  type              String    // "email", "sms", "push"
  channel           String    // "appointment_confirmation", "appointment_reminder", etc.
  recipient         String    // email address or phone number
  subject           String?
  content           String
  status            String    @default("PENDING") // PENDING, SENT, FAILED, RETRY
  attempts          Int       @default(0)
  maxAttempts       Int       @default(3)
  lastAttemptAt     DateTime?
  sentAt            DateTime?
  failureReason     String?
  metadata          Json?     // Additional data like template variables
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  
  // Relations
  user              User?     @relation("UserNotificationDeliveries", fields: [userId], references: [id])
  appointment       Appointment? @relation("AppointmentNotifications", fields: [appointmentId], references: [id])
  
  @@index([userId])
  @@index([appointmentId])
  @@index([status])
  @@index([type])
  @@index([channel])
  @@index([createdAt])
}

model NotificationTemplate {
  id                String    @id @default(cuid())
  name              String    @unique
  type              String    // "email", "sms", "push"
  channel           String    // "appointment_confirmation", "appointment_reminder", etc.
  subject           String?   // For email templates
  content           String    // Template content with placeholders
  variables         Json?     // Available template variables
  isActive          Boolean   @default(true)
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  
  @@index([name])
  @@index([type])
  @@index([channel])
  @@index([isActive])
}
