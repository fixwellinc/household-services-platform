generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                String                       @id @default(cuid())
  email             String                       @unique
  password          String
  name              String?
  role              String                       @default("CUSTOMER")
  avatar            String?
  phone             String?
  address           String?
  createdAt         DateTime                     @default(now())
  updatedAt         DateTime                     @updatedAt
  subscriptionId    String?
  serviceIds        String[]
  bookingIds        String[]
  messageIds        String[]
  quoteIds          String[]
  isActive          Boolean                      @default(true)
  notifications     Json?                        @default("{\"sms\": false, \"email\": true}")
  postalCode        String?
  assignedEmployee  CustomerEmployeeAssignment?  @relation("CustomerAssignment")
  assignedCustomers CustomerEmployeeAssignment[] @relation("EmployeeAssignments")
  subscriptionUsage SubscriptionUsage?
  
  // Add relation to Subscription
  subscription      Subscription?
  
  // New relations for complete workflow
  serviceRequests   ServiceRequest[] @relation("CustomerServiceRequests")
  technicianServiceRequests ServiceRequest[] @relation("TechnicianServiceRequests")
  technicianQuotes Quote[] @relation("TechnicianQuotes")
  customerJobs     Job[]   @relation("CustomerJobs")
  technicianJobs   Job[]   @relation("TechnicianJobs")
  customerInvoices Invoice[] @relation("CustomerInvoices")
  technicianInvoices Invoice[] @relation("TechnicianInvoices")
}

model CustomerEmployeeAssignment {
  id         String   @id @default(cuid())
  customerId String   @unique
  employeeId String
  assignedAt DateTime @default(now())
  updatedAt  DateTime @updatedAt
  customer   User     @relation("CustomerAssignment", fields: [customerId], references: [id])
  employee   User     @relation("EmployeeAssignments", fields: [employeeId], references: [id])
}

model Subscription {
  id                        String    @id @default(cuid())
  userId                    String    @unique
  tier                      String
  status                    String    @default("ACTIVE")
  stripeCustomerId          String?
  stripeSubscriptionId      String?
  currentPeriodStart        DateTime?
  currentPeriodEnd          DateTime?
  createdAt                 DateTime  @default(now())
  updatedAt                 DateTime  @updatedAt
  canCancel                 Boolean   @default(true)
  cancellationBlockedAt     DateTime?
  cancellationBlockedReason String?
  
  // Add relation back to User
  user                     User      @relation(fields: [userId], references: [id])
}

model SubscriptionUsage {
  id                     String    @id @default(cuid())
  userId                 String    @unique
  subscriptionId         String
  tier                   String
  priorityBookingUsed    Boolean   @default(false)
  priorityBookingUsedAt  DateTime?
  priorityBookingCount   Int       @default(0)
  discountUsed           Boolean   @default(false)
  discountUsedAt         DateTime?
  discountAmount         Float     @default(0)
  freeServiceUsed        Boolean   @default(false)
  freeServiceUsedAt      DateTime?
  freeServiceType        String?
  emergencyServiceUsed   Boolean   @default(false)
  emergencyServiceUsedAt DateTime?
  maxPriorityBookings    Int       @default(0)
  maxDiscountAmount      Float     @default(0)
  maxFreeServices        Int       @default(0)
  maxEmergencyServices   Int       @default(0)
  createdAt              DateTime  @default(now())
  updatedAt              DateTime  @updatedAt
  user                   User      @relation(fields: [userId], references: [id])
}

model Service {
  id          String   @id @default(cuid())
  name        String   @unique
  description String
  category    String
  complexity  String
  basePrice   Float
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  bookingIds  String[]
  quoteIds    String[]
  serviceRequestIds String[]
}

model Booking {
  id                    String   @id @default(cuid())
  customerId            String
  serviceId             String
  scheduledDate         DateTime
  status                String   @default("PENDING")
  totalAmount           Float
  discountAmount        Float   @default(0)
  finalAmount           Float
  notes                 String?
  stripePaymentIntentId String?
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  messageIds            String[]
  perkType              String?
  usedSubscriptionPerk  Boolean @default(false)
}

model Message {
  id         String   @id @default(cuid())
  bookingId  String
  senderId   String
  receiverId String
  content    String
  isRead     Boolean  @default(false)
  createdAt  DateTime @default(now())
}

model Quote {
  id               String    @id @default(cuid())
  userId           String?
  email            String
  serviceId        String?
  message          String
  status           String    @default("PENDING")
  adminReply       String?
  adminReplyPrice  Float?
  adminReplySentAt DateTime?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  serviceRequestId String?
  technicianId     String?
  estimatedHours   Float?
  materialsCost    Float?
  laborCost        Float?
  totalCost        Float?
  technicianNotes  String?
  customerAccepted Boolean   @default(false)
  acceptedAt       DateTime?
  serviceRequest   ServiceRequest? @relation("QuoteToServiceRequest", fields: [serviceRequestId], references: [id])
  technician       User?     @relation("TechnicianQuotes", fields: [technicianId], references: [id])
}

model Setting {
  id        String   @id @default(cuid())
  key       String   @unique
  value     String
  updatedAt DateTime @updatedAt
}

model EmailTemplate {
  id         String   @id @default(cuid())
  name       String   @unique
  subject    String
  body       String?
  html       String?
  isHtmlMode Boolean  @default(false)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  createdBy  String?
}

model ChatSession {
  id                 String        @id @default(cuid())
  customerName       String
  customerEmail      String?
  status             String        @default("ACTIVE")
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt
  lastAdminReadAt    DateTime?
  lastCustomerReadAt DateTime?
  messages           ChatMessage[]
}

model ChatMessage {
  id            String      @id @default(cuid())
  chatSessionId String
  sender        String
  senderType    String
  message       String
  sentAt        DateTime    @default(now())
  viaSMS        Boolean     @default(false)
  readBy        String[]
  fileName      String?
  fileType      String?
  fileUrl       String?
  chatSession   ChatSession @relation(fields: [chatSessionId], references: [id])
}

// New models for complete workflow
model ServiceRequest {
  id                String   @id @default(cuid())
  customerId        String
  serviceId         String?
  category          String
  description       String
  urgency           String   @default("NORMAL") // LOW, NORMAL, HIGH, EMERGENCY
  status            String   @default("PENDING") // PENDING, ASSIGNED, IN_PROGRESS, COMPLETED, CANCELLED
  photos            String[] // URLs to uploaded photos
  videos            String[] // URLs to uploaded videos
  address           String?
  preferredDate    DateTime?
  assignedTechnicianId String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  customer          User     @relation("CustomerServiceRequests", fields: [customerId], references: [id])
  service           Service? @relation("ServiceToServiceRequests", fields: [serviceId], references: [id])
  assignedTechnician User?   @relation("TechnicianServiceRequests", fields: [assignedTechnicianId], references: [id])
  quotes            Quote[]  @relation("QuoteToServiceRequest")
  jobs              Job[]
}

model Job {
  id                String   @id @default(cuid())
  serviceRequestId  String
  quoteId           String?
  customerId        String
  technicianId      String
  status            String   @default("SCHEDULED") // SCHEDULED, IN_PROGRESS, COMPLETED, CANCELLED
  scheduledDate     DateTime
  startTime         DateTime?
  endTime           DateTime?
  actualHours       Float?
  materialsUsed     String?
  notes             String?
  customerRating    Int?     // 1-5 stars
  customerFeedback  String?
  completedAt       DateTime?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  serviceRequest    ServiceRequest @relation("ServiceRequestToJob", fields: [serviceRequestId], references: [id])
  quote             Quote?   @relation("QuoteToJob", fields: [quoteId], references: [id])
  customer          User     @relation("CustomerJobs", fields: [customerId], references: [id])
  technician        User     @relation("TechnicianJobs", fields: [technicianId], references: [id])
  invoices          Invoice[]
}

model Invoice {
  id                String   @id @default(cuid())
  jobId             String
  customerId        String
  technicianId      String
  invoiceNumber     String   @unique
  subtotal          Float
  taxAmount         Float
  discountAmount    Float   @default(0)
  totalAmount       Float
  status            String   @default("PENDING") // PENDING, PAID, OVERDUE, CANCELLED
  dueDate           DateTime
  paidAt            DateTime?
  stripePaymentIntentId String?
  pdfUrl            String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  job               Job      @relation("JobToInvoice", fields: [jobId], references: [id])
  customer          User     @relation("CustomerInvoices", fields: [customerId], references: [id])
  technician        User     @relation("TechnicianInvoices", fields: [technicianId], references: [id])
}

enum SubscriptionTier {
  STARTER
  HOMECARE
  PRIORITY
}
